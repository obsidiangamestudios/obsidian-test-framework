using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace ObsidianGameStudios.NUnit.Database.SourceGenerators;

[Generator]
public class TestSuiteSourceGenerator : IIncrementalGenerator
{
    private const string FixtureAttributeName = "DatabaseTestSuiteAttribute";

    private const string Namespace = "ObsidianGameStudios.NUnit.Database";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context
            .SyntaxProvider.CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax,
                (ctx, _) => GetClassDeclarationForSourceGen(ctx)
            )
            .Where(c => c is { FullFixtureTypeName: not null });
        // Generate the source code.
        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(provider.Collect()),
            ((ctx, t) => GenerateCode(ctx, t.Left, t.Right))
        );
    }

    public enum DatabaseProvider
    {
        SqlServer = 10,
        Postgres = 20,
    }

    private void GenerateCode(
        SourceProductionContext ctx,
        Compilation compilation,
        ImmutableArray<ClassInfo> classes
    )
    {
        foreach (var classInfo in classes)
        {
            var classDeclarationSyntax = classInfo.Class;

            StringBuilder sb = new();

            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

            if (
                classDeclarationSyntax.TryGetClassSymbol(semanticModel, out var classSymbol)
                is false
            )
                continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
            var className = classDeclarationSyntax.Identifier.Text;

            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("using ObsidianGameStudios.NUnit.Database;");

            sb.AppendLine($"namespace {namespaceName};");
            sb.AppendLine($"partial class {className}");
            sb.AppendLine("{");

            var code = GetTestPartialClass(classInfo);

            sb.AppendLine(code);

            sb.AppendLine("}");

            ctx.AddSource($"{className}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }
    }

    private static string GetTestPartialClass(ClassInfo classInfo)
    {
        string code =
            $@"

    [SetUp]
    public async Task Setup()
    {{
        CurrentDbInfo = {classInfo.FullFixtureTypeName}.DatabaseFixture.TakeOne();
        await OnSetupAsync();
    }}

    [TearDown]
    public async Task TearDown()
    {{        
        await OnTearDownAsync();
        if (ShouldResetDatabase)
            await {classInfo.FullFixtureTypeName}.DatabaseFixture.ResetDatabaseAsync(CurrentDbInfo); 
        {classInfo.FullFixtureTypeName}.DatabaseFixture.ReturnOne(CurrentDbInfo);
        CurrentDbInfo = null;
    }}


    public async ValueTask DisposeAsync()
    {{
        await OnDisposeAsync();
    }}

    protected partial bool ShouldResetDatabase {{ get; }}
";

        if (!classInfo.OnSetupAsync)
            code += "\nprotected partial Task OnSetupAsync();\n";
        if (!classInfo.OnTearDownAsync)
            code += "\nprotected partial Task OnTearDownAsync();\n";
        if (!classInfo.OnDisposeAsync)
            code += "\nprotected partial Task OnDisposeAsync();\n";
        if (!classInfo.HasDbInfoProperty)
            code += "\nprotected DbInfo CurrentDbInfo { get; set; }\n";
        return code;
    }

    struct ClassInfo
    {
        public ClassDeclarationSyntax Class { get; set; }
        public string FullFixtureTypeName { get; set; }

        public bool HasDbInfoProperty { get; set; }
        public bool OnDisposeAsync { get; set; }
        public bool OnTearDownAsync { get; set; }
        public bool OnSetupAsync { get; set; }
    }

    private static ClassInfo GetClassDeclarationForSourceGen(GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;
        var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclarationSyntax) as INamedTypeSymbol;

        if (classSymbol == null)
            return new ClassInfo { Class = classDeclarationSyntax };
        ClassInfo classInfo = new() { Class = classDeclarationSyntax };
        classInfo.HasDbInfoProperty = HasProperty(classSymbol, "CurrentDbInfo");
        classInfo.OnDisposeAsync = HasMethod(classSymbol, "OnDisposeAsync");
        classInfo.OnTearDownAsync = HasMethod(classSymbol, "OnTearDownAsync");
        classInfo.OnSetupAsync = HasMethod(classSymbol, "OnSetupAsync");
        // Find all attributes with the name DataProperty and return the class declaration and the field declaration.
        foreach (var attributeListSyntax in classDeclarationSyntax.AttributeLists)
        {
            foreach (var attributeSyntax in attributeListSyntax.Attributes)
            {
                if (!context.TryGetAttributeMethodSymbol(attributeSyntax, out var attributeSymbol))
                    continue; // if we can't get the symbol, ignore it

                string attributeName = attributeSymbol.ContainingType.ToDisplayString();

                // Check the full name of the DataProperty attribute.
                if (attributeName == $"ObsidianGameStudios.NUnit.Database.{FixtureAttributeName}")
                {
                    // get all attributes values with the name DatabaseFixtureGenerator and return the class declaration and the field declaration.
                    var typeArgument = attributeSyntax.ArgumentList?.Arguments.Single();
                    string? typeValue = null;
                    if (typeArgument.Expression is TypeOfExpressionSyntax typeOfExpression)
                    {
                        var typeInfo = context.SemanticModel.GetTypeInfo(typeOfExpression.Type);
                        typeValue = typeInfo.Type?.ToDisplayString();
                    }

                    classInfo.FullFixtureTypeName = typeValue;
                }
            }
        }

        return classInfo;
    }

    private static bool HasProperty(INamedTypeSymbol classSymbol, string propertyName)
    {
        // Check if the class or any of its base types define a property with the specified name
        bool hasProperty = classSymbol
            .GetMembers()
            .OfType<IPropertySymbol>()
            .Any(p => p.Name == propertyName);

        if (!hasProperty)
        {
            var baseType = classSymbol.BaseType;
            while (baseType != null)
            {
                hasProperty = baseType
                    .GetMembers()
                    .OfType<IPropertySymbol>()
                    .Any(p => p.Name == propertyName);

                if (hasProperty)
                    break;

                baseType = baseType.BaseType;
            }
        }

        return hasProperty;
    }

    private static bool HasMethod(INamedTypeSymbol classSymbol, string methodName)
    {
        // Check if the class or any of its base types define a method with the specified name
        bool hasMethod = classSymbol
            .GetMembers()
            .OfType<IMethodSymbol>()
            .Any(m => m.Name == methodName && !m.IsPartial());

        if (!hasMethod)
        {
            var baseType = classSymbol.BaseType;
            while (baseType != null)
            {
                hasMethod = baseType
                    .GetMembers()
                    .OfType<IMethodSymbol>()
                    .Any(m => m.Name == methodName);

                if (hasMethod)
                    break;

                baseType = baseType.BaseType;
            }
        }

        return hasMethod;
    }
}
